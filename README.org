#+title: SPI-DMA-SD-Card
This project is a fork of a ControllersTech tutorial [[https://www.youtube.com/watch?time_continue=4&v=spVIZO-jbxE&source_ve_path=Mjg2NjY&feature=emb_logo][linked here]], modified to use DMA for SPI transmission and reception with an SD card.

The library uses a context-based API for easy integration and supports multiple SD card instances.

* Features
- DMA-based SPI communication for efficient data transfer
- Context struct for configuration (no compile-time macros needed)
- Standalone library - no FatFS dependency required
- Compatible with FatFS diskio interface

* API Overview
** SD_Context Structure
#+begin_src c
typedef struct {
    SPI_HandleTypeDef *spi_handle;   /* SPI peripheral handle */
    GPIO_TypeDef *cs_port;           /* Chip select GPIO port */
    uint16_t cs_pin;                 /* Chip select GPIO pin */
    /* ... internal state fields ... */
} SD_Context;
#+end_src

** Functions
| Function                | Description                                    |
|-------------------------+------------------------------------------------|
| =SD_init=               | Initialize context with hardware configuration |
| =SD_timer_tick=         | Call every 1ms from SysTick handler            |
| =SD_spi_tx_complete=    | Call from =HAL_SPI_TxCpltCallback=             |
| =SD_spi_rx_complete=    | Call from =HAL_SPI_RxCpltCallback=             |
| =SD_spi_txrx_complete=  | Call from =HAL_SPI_TxRxCpltCallback=           |
| =SD_disk_initialize=    | Initialize SD card                             |
| =SD_disk_status=        | Get disk status                                |
| =SD_disk_read=          | Read sectors                                   |
| =SD_disk_write=         | Write sectors                                  |
| =SD_disk_ioctl=         | Disk control operations                        |

* Usage
** 1. CubeMX Configuration
- Enable SPI in Master mode
- Enable Tx and Rx DMA for SPI under SPI -> DMA settings
- Enable SPI global interrupt under SPI -> NVIC settings
- Configure a GPIO pin for chip select (directly, not via SPI NSS)

** 2. Include the Library
Add to your CMakeLists.txt:
#+begin_src cmake
add_subdirectory(lib/stm32-spi-dma-sdcard)
target_link_libraries(${PROJECT_NAME} stm32-spi-dma-sdcard)
#+end_src

** 3. Initialize and Use
#+begin_src c
#include "sd_functions.h"

/* Global context */
SD_Context sd_ctx;

/* In main(), after peripheral initialization */
void main(void) {
    /* ... HAL init, clock config, peripheral init ... */
    
    /* Initialize SD card context */
    SD_init(&sd_ctx, &hspi1, GPIOA, GPIO_PIN_4);
    
    /* Initialize the SD card */
    if (SD_disk_initialize(&sd_ctx) == 0) {
        /* Card initialized successfully */
        uint8_t buffer[512];
        SD_disk_read(&sd_ctx, buffer, 0, 1);  /* Read sector 0 */
    }
}
#+end_src

** 4. Setup Callbacks
In your =stm32xxxx_it.c= or callback file:
#+begin_src c
#include "sd_functions.h"
extern SD_Context sd_ctx;

/* In SysTick_Handler */
void SysTick_Handler(void) {
    HAL_IncTick();
    SD_timer_tick(&sd_ctx);
}

/* SPI DMA callbacks */
void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi) {
    SD_spi_tx_complete(&sd_ctx);
}

void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi) {
    SD_spi_rx_complete(&sd_ctx);
}

void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi) {
    SD_spi_txrx_complete(&sd_ctx);
}
#+end_src

** 5. FatFS Integration (Optional)
If using FatFS, implement the diskio functions by calling the SD_* equivalents:
#+begin_src c
#include "sd_functions.h"
extern SD_Context sd_ctx;

DSTATUS disk_initialize(BYTE pdrv) {
    return SD_disk_initialize(&sd_ctx);
}

DSTATUS disk_status(BYTE pdrv) {
    return SD_disk_status(&sd_ctx);
}

DRESULT disk_read(BYTE pdrv, BYTE* buff, DWORD sector, UINT count) {
    return SD_disk_read(&sd_ctx, buff, sector, count);
}

DRESULT disk_write(BYTE pdrv, const BYTE* buff, DWORD sector, UINT count) {
    return SD_disk_write(&sd_ctx, buff, sector, count);
}

DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void* buff) {
    return SD_disk_ioctl(&sd_ctx, cmd, buff);
}
#+end_src

* How it Works
The library uses DMA for SPI Send and Receive operations. A =dma_complete= flag in the context is managed by the SPI callbacks to ensure each transaction completes before the next one starts. Timer callbacks provide timeout functionality for SD card operations.
